---
layout: post
title: "Syntax"
date: "2018-08-26 12:55:36 -0700"
categories: JavaScript
description: Basic Syntax
---

üîç [let and const](#let-and-const) üîç [Template Literals](#template-literals)

---

#### Hoisting

Hoisting is a result of how JavaScript is interpreted by your browser. Essentially, before any JavaScript code is executed, all variables are "hoisted", which means they're raised to the top of the function scope. So at run-time, the `getClothing()` function actually looks more like this‚Ä¶

Without Hoisting...

{% highlight js %}
function getClothing(isCold) {
  if (isCold) {
    var freezing = 'Grab a jacket!';
  } else {
    var hot = 'It‚Äôs a shorts kind of day.';
    console.log(freezing);
  }
}
{% endhighlight %}

With Hoisting...

{% highlight js %}
function getClothing(isCold) {
  var freezing, hot;
  if (isCold) {
    freezing = 'Grab a jacket!';
  } else {
    hot = 'It‚Äôs a shorts kind of day.';
    console.log(freezing);
  }
}
{% endhighlight %}

## let and const

Variables declared with `let` and `const` eliminate this specific issue of hoisting because they‚Äôre scoped to the block, not to the function. Previously, when you used `var`, variables were either scoped globally or locally to an entire function scope.

If a variable is declared using `let` or `const` inside a block of code (denoted by curly braces `{ }`), then the variable is stuck in what is known as the temporal dead zone until the variable‚Äôs declaration is processed. This behavior prevents variables from being accessed only until after they‚Äôve been declared.

{% highlight js %}
function getClothing(isCold) {
  if (isCold) {
    let freezing = 'Grab a jacket!';
  } else {
    let hot = 'It‚Äôs a shorts kind of day.';
    console.log(freezing);
  }
}
{% endhighlight %}

#### üëì Read more about Links at:

  - [3wschools - let](https://www.w3schools.com/js/js_let.asp)

  - [3wschools - const](https://www.w3schools.com/js/js_const.asp)


## Rules for using let and const

`let` and `const` also have some other interesting properties.

  - Variables declared with `let` can be reassigned, but can‚Äôt be redeclared in the same scope.

  - Variables declared with `const` must be assigned an initial value, but can‚Äôt be redeclared in the same scope, and can‚Äôt be reassigned.

## Use cases

The big question is when should you use `let` and `const`? The general rule of thumb is as follows:

  - use `let` when you plan to reassign new values to a variable

  - use `const` when you don‚Äôt plan on reassigning new values to a variable

Since `const` is the strictest way to declare a variable, we suggest that you always declare variables with `const` because it'll make your code easier to reason about since you know the identifiers won't change throughout the lifetime of your program. If you find that you need to update a variable or change it, then go back and switch it from `const` to `let`.

## What about var?

Is there any reason to use `var` anymore? Not really.

There are some arguments that can be made for using `var` in situations where you want to globally define variables, but this is often considered bad practice and should be avoided. From now on, we suggest ditching `var` in place of using `let` and `const`.

## Prior to ES6...

the old way to concatenate strings together was by using the string concatenation operator ( `+` ).

{% highlight js %}
const student = {
  name: 'Richard Kalehoff',
  guardian: 'Mr. Kalehoff'
};

const teacher = {
  name: 'Mrs. Wilson',
  room: 'N231'
}

let message = student.name + ' please see ' + teacher.name + ' in ' + teacher.room + ' to pick up your report card.';
{% endhighlight %}

Console will print: `Richard Kalehoff please see Mrs. Wilson in N231 to pick up your report card.`

This works alright, but it gets more complicated when you need to build multi-line strings.

{% highlight js %}
let note = teacher.name + ',\n\n' +
  'Please excuse ' + student.name + '.\n' +
  'He is recovering from the flu.\n\n' +
  'Thank you,\n' +
  student.guardian;
{% endhighlight %}

Console will print:

{% highlight html %}
Mrs. Wilson,

Please excuse Richard Kalehoff.
He is recovering from the flu.

Thank you,
Mr. Kalehoff
{% endhighlight %}

However, that‚Äôs changed with the introduction of template literals (previously referred to as "template strings" in development releases of ES6).

üí• As an alternative to using the string concatenation operator ( `+` ), you can use the String's `concat()` method, but both options are rather clunky for simulating true [string interpolation](https://en.wikipedia.org/wiki/String_interpolation).

## Template Literals

Template literals are essentially string literals that include embedded expressions.

Denoted with backticks ( ) instead of single quotes ( `''` ) or double quotes ( `""` ), template literals can contain placeholders which are represented using `${expression}`. This makes it much easier to build strings.

Here's the previous examples using template literals.

{% highlight js %}
let message = `${student.name} please see ${teacher.name} in ${teacher.room} to pick up your report card.`;
{% endhighlight %}

Console will print: `Richard Kalehoff please see Mrs. Wilson in N231 to pick up your report card.`

By using template literals, you can drop the quotes along with the string concatenation operator. Also, you can reference the object's properties inside expressions.

Here‚Äôs where template literals really shine. In above, the quotes and string concatenation operator have been dropped, as well as the newline characters ( `\n` ). That's because template literals also preserve newlines as part of the string!

{% highlight js %}
let note = `${teacher.name}.

  Please excuse ${student.name}.
  He is recovering from the flu.

  Thank you,
  ${student.guardian}`;
{% endhighlight %}

Console will print the same:

{% highlight html %}
Mrs. Wilson,

Please excuse Richard Kalehoff.
He is recovering from the flu.

Thank you,
Mr. Kalehoff
{% endhighlight %}
